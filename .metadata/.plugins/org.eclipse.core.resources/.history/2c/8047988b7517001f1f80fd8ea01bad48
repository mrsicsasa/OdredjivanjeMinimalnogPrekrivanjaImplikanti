package application;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Label;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableRow;
import javafx.scene.control.TableView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class Main extends Application {

    private TableView<Implicant> tableView;
    private Label explanationLabel;
    private Rectangle statusIndicator;

    public ArrayList<Implicant> getGrupeProstihImplikanti() {
        Implicant i1 = new Implicant(2, 6, 10, 14);
        Implicant i2 = new Implicant(8, 9, 10, 11);
        Implicant i3 = new Implicant(10, 11, 14, 15);
        ArrayList<Implicant> implicants = new ArrayList<>();
        implicants.add(i1);
        implicants.add(i2);
        implicants.add(i3);
        return implicants;
    }

    @Override
    public void start(Stage primaryStage) {
        try {
            BorderPane root = new BorderPane();

            tableView = new TableView<>();

            // Kolona za grupu implikanata
            TableColumn<Implicant, String> implicantColumn = new TableColumn<>("Grupe implikanti");
            implicantColumn.setCellValueFactory(data -> {
                Implicant implicant = data.getValue();
                return new SimpleStringProperty(implicant.getVrednostImplikante().toString());
            });
            implicantColumn.setPrefWidth(150); // Podesite širinu kolone
            tableView.getColumns().add(implicantColumn);

            // Dodavanje kolona za jedinstvene implikante
            Set<Integer> uniqueImplicants = getUniqueImplicants();
            for (Integer implicant : uniqueImplicants) {
                TableColumn<Implicant, String> implicantCol = new TableColumn<>(implicant.toString());
                implicantCol.setCellValueFactory(data -> {
                    Implicant rowImplicant = data.getValue();
                    if (rowImplicant.getVrednostImplikante().contains(implicant)) {
                        return new SimpleStringProperty("X");
                    } else {
                        return new SimpleStringProperty("");
                    }
                });
                implicantCol.setPrefWidth(50); // Podesite širinu kolone
                tableView.getColumns().add(implicantCol);
            }

            // Podesite minimalnu i maksimalnu širinu tabele
            tableView.setMinWidth(600);
            tableView.setMaxWidth(800);

            // Dodavanje vrednosti u tabelu
            tableView.getItems().addAll(getGrupeProstihImplikanti());

            tableView.setOnMouseClicked(this::handleRowSelection);

            // Dodavanje labele i indikatora
            explanationLabel = new Label("Naucicete kako da minimizirate prekidacku funkciju koriscenjem McCluskey metode.");
            statusIndicator = new Rectangle(100, 20, Color.GRAY);

            VBox rightPane = new VBox(10, new Label("Objasnjenje:"), explanationLabel, statusIndicator);
            rightPane.setPadding(new javafx.geometry.Insets(10));

            root.setCenter(tableView);
            root.setRight(rightPane);

            Scene scene = new Scene(root, 1100, 400); // Povećajte širinu scene za bolji prikaz
            scene.getStylesheets().add(getClass().getResource("application.css").toExternalForm());

            primaryStage.setScene(scene);
            primaryStage.setTitle("Edukativni režim - Minimizacija prekidačke funkcije");
            primaryStage.show();

            // Dodavanje rowFactory za bojanje redova
//            tableView.setRowFactory(tv -> {
//                TableRow<Implicant> row = new TableRow<>();
//                row.setOnMouseClicked(event -> {
//                    if (!row.isEmpty()) {
//                        Implicant selectedImplicant = row.getItem();
//                        if (isCorrectImplicant(selectedImplicant)) {
//                            row.setStyle("-fx-background-color: lightgreen;");
//                            statusIndicator.setFill(Color.GREEN);
//                            showAlert(Alert.AlertType.INFORMATION, "Dobar izbor", "Izabrali ste dobru implikantu!");
//                        } else {
//                            row.setStyle("");
//                            statusIndicator.setFill(Color.RED);
//                            showAlert(Alert.AlertType.ERROR, "Pogresan izbor", "Niste izabrali dobru implikantu. Razlog je sledeci:");
//                        }
//                    }
//                });
//                return row;
//            });

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private Set<Integer> getUniqueImplicants() {
        Set<Integer> uniqueImplicants = new HashSet<>();
        for (Implicant implicant : getGrupeProstihImplikanti()) {
            uniqueImplicants.addAll(implicant.getVrednostImplikante());
        }
        return uniqueImplicants;
    }

    private void handleRowSelection(MouseEvent event) {
        Implicant selectedImplicant = tableView.getSelectionModel().getSelectedItem();
        if (selectedImplicant != null) {
            if (isCorrectImplicant(selectedImplicant)) {
                statusIndicator.setFill(Color.GREEN);
                showAlert(Alert.AlertType.INFORMATION, "Dobar izbor", "Izabrali ste dobru implikantu!");
            } else {
                statusIndicator.setFill(Color.RED);
                showAlert(Alert.AlertType.ERROR, "Pogresan izbor", "Niste izabrali dobru implikantu. Razlog je sledeci:");
            }
            tableView.refresh(); // Osvježite tabelu da bi se boja ažurirala
        }
    }

    private boolean isCorrectImplicant(Implicant implicant) {
        // Logika za proveru da li je izabrana implikanta ispravna
        // Ovo je primer, u stvarnosti treba proveriti prema zadatoj funkciji
    	//da li se pojavljuje u drugoj implikanti,i ako se nalazi u drugoj grupi,oznaciti gde,barem koji red 
        return implicant.getVrednostImplikante().contains(9);
    }

    private void showAlert(Alert.AlertType alertType, String title, String message) {
        Alert alert = new Alert(alertType);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
